# FAQ

## Fluentd is written in Ruby, is it slow?

Fluentd is written in C for the performance sensitive part, and Ruby for the flexibility. Especially, the networking layer and object serialization layer is written in C (See [cool.io](https://github.com/tarcieri/cool.io) and [MessagePack](http://msgpack.org/)).

It's not perfectly written in C or C++, so might be slow in Ruby part. But Thanks to Ruby community, we have [a lot of plugins](http://fluentd.org/plugin/) :) Besides the fact that Fluentd is used at [many large services](users), actually the normal box will achieve 18k messages per sec with a single proceses.

If you think that number is insufficient for you, you can go for other solutions which is completely written in C-family or Java but you'll lose the flexibility in some sense. 

## What is the difference with td-agent and Fluentd?

In one word, td-agent is a stable package distribution of Fluentd. There're following differences.

* td-agent is distributed as [deb](install-by-deb)/[rpm](install-by-rpm) package, while Fluentd is distributed by [Ruby gem](install-by-gem).
* td-agent contains Ruby interpreter itself in the package, while Fluentd not.
* td-agent contains /etc/init.d/ script, while Fluentd not.
* td-agent contains stable version of Fluentd, with some plugins compatible with that version.
* td-agent contains [jemalloc](http://www.canonware.com/jemalloc/), to prevent memory fragmentations on heavy loaded sites.

## Should I use td-agent or fluentd gem?

td-agent takes its importance on stability over new features. If you want to control the features and new changes by yourself, using fluentd gem is recommended. If you use Fluentd for the first time or use it at the large scale environment, using td-agent is recommended. td-agent is released every 2 or 3 months.

## What is 'tag'?

The message inside Fluentd consists of the three entities.

* time
* tag
* message

Every time you post the log, you need to specify the tag. The tag are used to route the message with in Fluentd. In the configuration file, you have 'match' section to specify which tags are routed to that configuration.

Let's look at the example. This configuration tails /var/log/combine.log, and generates the log with tag 'test-tag.'

    :::term
    <source>
      type tail
      format /^(?<wholemsg>.*)$/
      path /var/log/combined.log 
      tag test-tag
    </source> 

Then if you add these lines to the document, the logs are printed to stdout.

    :::term
    <match test-tag> 
      type stdout
    </match>

On the other hand, this doesn't show nothing, because match section doesn't match the tag.

    :::term
    <match some-other-tag>
      type stdout
    </match>

In conclusion, you can have a control of how to process the data by using tags.

## How to estimate Fluentd's resource usage?

Fluentd consumes more resources, when you throw more logs. From our observation, CPU is a major bottleneck for heavy loaded Fluentd systems. To utilize multiple CPU cores, Fluentd also supports multi-process mode. The normal PC box could handle around 18,000 msgs/second.

## How about Fluentd's performance?

The most of performance sensitive parts are carefully written as Ruby's C extensions. In addition to that, Fluentd supports multi process mode, to leverage multiple CPU cores.

From our experiment, normal PC box could deliver 18,000 messages / second. If you need more higher, please consider using multiple Fluentd servers. If you need 100x performance, you should look at another or your own solution.

## What is the difference with Splunk?

Splunk is a log collection + search engine for unstrucuted, text-based log. If has a nice UI and indexing engine, to search the term fron the text log files.

Fluentd is a log collector daemon, for semi-structured JSON-based log. It deals with machine-readable logs, while Splunk handles text-based log. Also Fluentd is a mechanism of just receive, buffer, and forward the data into another place. No search engine functionality.

## I've got a weird timestamp value, what happened?

Fluentd and its logger libraries depend on your system's clock for timestamp value. So it's highly recommended to setup NTP on your node, to keep your clock synched with correct clocks.
